#include <stdio.h>//叉乘
int main()
{
	int a, b, c;
	int arrA[3][4] = { {1,2},{3,4},{5,6} };//创建矩阵AB
	printf("矩阵A:\n");
	for (a = 0; a < 3; a++)//行的坐标
	{
		for (c = 0; c < 4; c++)//列的坐标
		printf(" %d", arrA[a][c]);
		printf("\n");//打出一行后下一行继续循环
	}
	int arrB[4][3] = { {7,8},{9,10},{11,12},{13,14} };//叉乘的前提是一个矩阵的列等于另一个矩阵的行
	printf("矩阵B:\n");
	for (c = 0; c < 4; c++)
	{
		for (b = 0; b < 3; b++)
			printf(" %d", arrB[c][b]);
		printf("\n");
	}
	int arrC[3][3]={0};//初始化矩阵C,[3][4]*[4][3]得到的就是[3][3]
	for (a=0;a<3;a++)//这一步我感觉是最难想的，要写草稿，要试，还去参考了别人的，然后才搞明白了，点乘就感觉简单一些。
	{
		for (b = 0; b < 3; b++)//C的值是4组AB对应的元素相乘后相加，所以C的坐标暂时不变，然后A是纵坐标变，B是横坐标变。所以先确实C是[a][b]时，A的[a][c]和B的[c][b]就确定下来了。
		{
			for (c = 0; c < 4; c++)//所以c的循环放最里面，等c循环完，C[0][0]的元素就确定了，然后到C[0][1],再进行c的循环，一直下去
			{
				arrC[a][b] = arrC[a][b] + arrA[a][c] * arrB[c][b];//之所以是+=而不是=是因为叉乘是将元素对应相乘再相加
			}
		}


	}
	printf("矩阵A乘B的结果：\n");
	for (a = 0; a < 3; a++)
	{
		for (b = 0; b < 3; b++)
			printf(" %d", arrC[a][b]);
		printf("\n");
	}

	


	return 0;
}